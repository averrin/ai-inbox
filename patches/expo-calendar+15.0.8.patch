diff --git a/node_modules/expo-calendar/android/.project b/node_modules/expo-calendar/android/.project
new file mode 100644
index 0000000..06eaaf2
--- /dev/null
+++ b/node_modules/expo-calendar/android/.project
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>expo-calendar</name>
+	<comment>Project expo-calendar created by Buildship.</comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.buildship.core.gradleprojectbuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+		<nature>org.eclipse.buildship.core.gradleprojectnature</nature>
+	</natures>
+	<filteredResources>
+		<filter>
+			<id>1770632961366</id>
+			<name></name>
+			<type>30</type>
+			<matcher>
+				<id>org.eclipse.core.resources.regexFilterMatcher</id>
+				<arguments>node_modules|\.git|__CREATED_BY_JAVA_LANGUAGE_SERVER__</arguments>
+			</matcher>
+		</filter>
+	</filteredResources>
+</projectDescription>
diff --git a/node_modules/expo-calendar/android/bin/src/main/java/expo/modules/calendar/EventNotSavedException.class b/node_modules/expo-calendar/android/bin/src/main/java/expo/modules/calendar/EventNotSavedException.class
new file mode 100644
index 0000000..828fe4e
Binary files /dev/null and b/node_modules/expo-calendar/android/bin/src/main/java/expo/modules/calendar/EventNotSavedException.class differ
diff --git a/node_modules/expo-calendar/android/src/main/java/expo/modules/calendar/CalendarEventBuilder.kt b/node_modules/expo-calendar/android/src/main/java/expo/modules/calendar/CalendarEventBuilder.kt
index 02d7e3f..aa7f32f 100644
--- a/node_modules/expo-calendar/android/src/main/java/expo/modules/calendar/CalendarEventBuilder.kt
+++ b/node_modules/expo-calendar/android/src/main/java/expo/modules/calendar/CalendarEventBuilder.kt
@@ -87,5 +87,9 @@ class CalendarEventBuilder(
     }
   }
 
+  fun remove(key: String) = apply {
+    eventValues.remove(key)
+  }
+
   fun build() = eventValues
 }
diff --git a/node_modules/expo-calendar/android/src/main/java/expo/modules/calendar/CalendarModule.kt b/node_modules/expo-calendar/android/src/main/java/expo/modules/calendar/CalendarModule.kt
index 5579727..a86a3cf 100644
--- a/node_modules/expo-calendar/android/src/main/java/expo/modules/calendar/CalendarModule.kt
+++ b/node_modules/expo-calendar/android/src/main/java/expo/modules/calendar/CalendarModule.kt
@@ -134,11 +134,12 @@ class CalendarModule : Module() {
       }
     }
 
-    AsyncFunction("saveEventAsync") { details: ReadableArguments, _: ReadableArguments?, promise: Promise ->
+    AsyncFunction("saveEventAsync") { details: ReadableArguments, options: ReadableArguments?, promise: Promise ->
+      Log.e(TAG, "saveEventAsync (patched) called with options: $options")
       withPermissions(promise) {
         launchAsyncWithModuleScope(promise) {
           try {
-            val eventID = saveEvent(details)
+            val eventID = saveEvent(details, options)
             promise.resolve(eventID.toString())
           } catch (e: ParseException) {
             promise.reject("E_EVENT_NOT_SAVED", "Event could not be saved", e)
@@ -146,6 +147,9 @@ class CalendarModule : Module() {
             promise.reject("E_EVENT_NOT_SAVED", "Event could not be saved", e)
           } catch (e: InvalidArgumentException) {
             promise.reject("E_EVENT_NOT_SAVED", "Event could not be saved", e)
+          } catch (e: Throwable) {
+            Log.e(TAG, "Unexpected error in saveEventAsync", e)
+            promise.reject("E_EVENT_NOT_SAVED", "Unexpected error: ${e.message}", Exception(e))
           }
         }
       }
@@ -428,7 +432,8 @@ class CalendarModule : Module() {
   }
 
   @Throws(EventNotSavedException::class, ParseException::class, SecurityException::class, InvalidArgumentException::class)
-  private fun saveEvent(details: ReadableArguments): Int {
+  private fun saveEvent(details: ReadableArguments, options: ReadableArguments?): Int {
+    Log.e(TAG, "saveEvent called. InstanceStartDate present: ${details.containsKey("instanceStartDate")}")
     val calendarEventBuilder = CalendarEventBuilder(details)
     if (details.containsKey("startDate")) {
       val startCal = Calendar.getInstance()
@@ -467,11 +472,13 @@ class CalendarModule : Module() {
           if (parsedDate != null) {
             endCal.time = parsedDate
             calendarEventBuilder.put(CalendarContract.Events.DTEND, endCal.timeInMillis)
+            calendarEventBuilder.remove(CalendarContract.Events.DURATION)
           } else {
             Log.e(TAG, "Parsed date is null")
           }
         } else if (endDate is Number) {
           calendarEventBuilder.put(CalendarContract.Events.DTEND, endDate.toLong())
+          calendarEventBuilder.remove(CalendarContract.Events.DURATION)
         }
       } catch (e: ParseException) {
         Log.e(TAG, "error", e)
@@ -483,7 +490,7 @@ class CalendarModule : Module() {
       if (recurrenceRule.containsKey("frequency")) {
         val opts = extractRecurrence(recurrenceRule)
 
-        if (opts.endDate == null && opts.occurrence == null) {
+        if (opts.endDate == null && opts.occurrence == null && !details.containsKey("instanceStartDate")) {
           val eventStartDate = calendarEventBuilder.getAsLong(CalendarContract.Events.DTSTART)
           val eventEndDate = calendarEventBuilder.getAsLong(CalendarContract.Events.DTEND)
           val duration = (eventEndDate - eventStartDate) / 1000
@@ -491,6 +498,8 @@ class CalendarModule : Module() {
             .putNull(CalendarContract.Events.LAST_DATE)
             .putNull(CalendarContract.Events.DTEND)
             .put(CalendarContract.Events.DURATION, "PT${duration}S")
+          
+          calendarEventBuilder.remove(CalendarContract.Events.DTEND)
         }
         val rule = createRecurrenceRule(opts)
         calendarEventBuilder.put(CalendarContract.Events.RRULE, rule)
@@ -514,6 +523,46 @@ class CalendarModule : Module() {
 
     return if (details.containsKey("id")) {
       val eventID = details.getString("id").toInt()
+
+      // Handle "This event only" update by creating an exception
+      if (details.containsKey("instanceStartDate")) {
+        val instanceStartDate = details["instanceStartDate"]
+        var originalInstanceTime: Long? = null
+        try {
+          if (instanceStartDate is String) {
+            val parsedDate = sdf.parse(instanceStartDate)
+            if (parsedDate != null) originalInstanceTime = parsedDate.time
+          } else if (instanceStartDate is Number) {
+            originalInstanceTime = instanceStartDate.toLong()
+          }
+        } catch (e: Exception) {
+          Log.e(TAG, "Error parsing instanceStartDate", e)
+        }
+
+        if (originalInstanceTime != null) {
+            val cv = calendarEventBuilder.build()
+            cv.put(CalendarContract.Events.ORIGINAL_ID, eventID.toString())
+            cv.put(CalendarContract.Events.ORIGINAL_INSTANCE_TIME, originalInstanceTime)
+            cv.put(CalendarContract.Events.STATUS, CalendarContract.Events.STATUS_CONFIRMED)
+            
+            // For instances of recurring events, clear recurrence fields to prevent DTEND/DURATION logic conflicts
+            cv.remove(CalendarContract.Events.RRULE)
+            cv.remove(CalendarContract.Events.RDATE)
+            cv.remove(CalendarContract.Events.EXRULE)
+            cv.remove(CalendarContract.Events.EXDATE)
+            cv.remove(CalendarContract.Events.DURATION)
+            
+            // Log final state to debug if "both" error persists
+            if (cv.containsKey(CalendarContract.Events.DTEND) && cv.containsKey(CalendarContract.Events.DURATION)) {
+                Log.e(TAG, "STILL CONFLICTING! Removing DURATION as a last resort.")
+                cv.remove(CalendarContract.Events.DURATION)
+            }
+
+            val uri = contentResolver.insert(CalendarContract.Events.CONTENT_URI, cv) ?: throw EventNotSavedException()
+            return uri.lastPathSegment!!.toInt()
+        }
+      }
+
       val updateUri = ContentUris.withAppendedId(CalendarContract.Events.CONTENT_URI, eventID.toLong())
       contentResolver.update(updateUri, calendarEventBuilder.build(), null, null)
       removeRemindersForEvent(eventID)
diff --git a/node_modules/expo-calendar/android/src/main/java/expo/modules/calendar/EventRecurrenceUtils.kt b/node_modules/expo-calendar/android/src/main/java/expo/modules/calendar/EventRecurrenceUtils.kt
index 8df7420..9671fe8 100644
--- a/node_modules/expo-calendar/android/src/main/java/expo/modules/calendar/EventRecurrenceUtils.kt
+++ b/node_modules/expo-calendar/android/src/main/java/expo/modules/calendar/EventRecurrenceUtils.kt
@@ -55,7 +55,7 @@ object EventRecurrenceUtils {
 
   fun createRecurrenceRule(opts: Recurrence): String {
     val (frequency, interval, endDate, occurrence) = opts
-    var rrule: String = when (frequency) {
+    var rrule: String = when (frequency.lowercase()) {
       "daily" -> "FREQ=DAILY"
       "weekly" -> "FREQ=WEEKLY"
       "monthly" -> "FREQ=MONTHLY"
@@ -69,6 +69,11 @@ object EventRecurrenceUtils {
       rrule += ";UNTIL=$endDate"
     } else if (occurrence != null) {
       rrule += ";COUNT=$occurrence"
+    } else {
+        // Workaround for Android/Samsung infinite recurrence crash
+        // If no end date or count is specified, default to a safe limit (e.g., 365 occurrences)
+        // This prevents native crashes in the Calendar Provider.
+        rrule += ";COUNT=365"
     }
     return rrule
   }
