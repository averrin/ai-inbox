diff --git a/components/screens/ScheduleEvent.tsx b/components/screens/ScheduleEvent.tsx
index 5f49c14..809b4d7 100644
--- a/components/screens/ScheduleEvent.tsx
+++ b/components/screens/ScheduleEvent.tsx
@@ -118,7 +118,7 @@ export const ScheduleEvent = ({ event: evt, touchableOpacityProps, timeFormat }:
     const isCompact = duration <= 30;
 
     // Special styling for generated lunch suggestions
-    const isLunchSuggestion = evt.type === 'generated' && evt.typeTag === 'LUNCH_SUGGESTION';
+    const isLunchSuggestion = evt.typeTag === 'LUNCH_SUGGESTION';
     const containerStyle: any = {};
     if (isLunchSuggestion) {
         containerStyle.backgroundColor = (evt.color || '#22c55e') + '66'; // Opacity 40% (hex 66)
diff --git a/components/screens/ScheduleScreen.tsx b/components/screens/ScheduleScreen.tsx
index 7d4af32..6249ce5 100644
--- a/components/screens/ScheduleScreen.tsx
+++ b/components/screens/ScheduleScreen.tsx
@@ -1,5 +1,5 @@
 import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
-import { View, Text, TouchableOpacity, useWindowDimensions, NativeSyntheticEvent, NativeScrollEvent, RefreshControl } from 'react-native';
+import { View, Text, TouchableOpacity, useWindowDimensions, NativeSyntheticEvent, NativeScrollEvent, RefreshControl, Alert, Platform } from 'react-native';
 import { SafeAreaView, useSafeAreaInsets } from 'react-native-safe-area-context';
 import { Calendar as BigCalendar, CalendarRef } from '../ui/calendar';
 import dayjs from 'dayjs';
@@ -23,7 +23,7 @@ import { DayStatusMarker } from '../DayStatusMarker'; import { DaySummaryModal }
 import { ReminderEditModal, ReminderSaveData } from '../ReminderEditModal';
 import { updateReminder, toLocalISOString, createStandaloneReminder, Reminder } from '../../services/reminderService';
 import { EventCreateModal, EventSaveData } from '../EventCreateModal';
-import { createCalendarEvent, getWritableCalendars } from '../../services/calendarService';
+import { createCalendarEvent, getWritableCalendars, updateCalendarEvent } from '../../services/calendarService';
 
 import { getWeatherForecast, getWeatherIcon, WeatherData } from '../../services/weatherService';
 import { useMoodStore } from '../../store/moodStore';
@@ -176,33 +176,31 @@ export default function ScheduleScreen() {
             const mappedEvents = nativeEvents.map(evt => {
                 let assignedTypeId = assignments[evt.title];
 
+                const attendees = (evt as any).attendees || [];
+                const normalize = (e: string) => e?.toLowerCase().trim();
+                const myEmailsSet = new Set((myEmails || []).map(normalize));
+                const isMe = (email: string) => myEmailsSet.has(normalize(email));
+
+                const uniqueAttendees = new Map();
+                attendees.forEach((a: any) => {
+                    if (a.email) {
+                        const email = normalize(a.email);
+                        // Ignore Google resource calendars (conference rooms)
+                        if (email.endsWith('resource.calendar.google.com')) return;
+                        uniqueAttendees.set(email, a);
+                    }
+                });
+
+                const isPersonal = uniqueAttendees.size === 0 || Array.from(uniqueAttendees.keys()).every(email => isMe(email));
+
                 // Auto-detect type if not assigned
                 if (!assignedTypeId) {
-                    const attendees = (evt as any).attendees || [];
-                    const normalize = (e: string) => e?.toLowerCase().trim();
-                    const myEmailsSet = new Set((myEmails || []).map(normalize));
-                    const isMe = (email: string) => myEmailsSet.has(normalize(email));
-
-                    const uniqueAttendees = new Map();
-                    attendees.forEach((a: any) => {
-                        if (a.email) {
-                            const email = normalize(a.email);
-                            // Ignore Google resource calendars (conference rooms)
-                            if (email.endsWith('resource.calendar.google.com')) return;
-                            uniqueAttendees.set(email, a);
-                        }
-                    });
-
+                    const count = uniqueAttendees.size;
                     let hasMe = false;
                     uniqueAttendees.forEach((_, email) => {
                         if (isMe(email)) hasMe = true;
                     });
 
-                    // Check if organizer is me (if not in attendees)
-                    // (Skipping complex organizer logic for now, relying on attendees list)
-
-                    const count = uniqueAttendees.size;
-
                     if (count === 0 || (count === 1 && hasMe)) {
                         // Only Me -> Personal
                         const personalType = eventTypes.find(t => t.title.toLowerCase() === 'personal');
@@ -240,8 +238,10 @@ export default function ScheduleScreen() {
                 );
 
                 // Resolve merged calendars
-                const mergedIds = (evt as any).mergedCalendarIds || [evt.calendarId];
-                const sourceCalendars = mergedIds.map((id: string) => {
+                const mergedCalIds = (evt as any).mergedCalendarIds || [evt.calendarId];
+                const mergedEvtIds = (evt as any).mergedEventIds || [evt.id];
+                
+                const sourceCalendars = mergedCalIds.map((id: string) => {
                     const details = (calDetailsMap as any)[id];
                     return {
                         id,
@@ -255,7 +255,6 @@ export default function ScheduleScreen() {
 
                 const sourceName = (calDetailsMap as any)[evt.calendarId]?.source || '';
                 const calendarTitle = (calDetailsMap as any)[evt.calendarId]?.title || '';
-                const attendees = (evt as any).attendees;
                 let currentUserRSVP = '';
                 if (Array.isArray(attendees)) {
                     let match = attendees.find((a: any) => a.isCurrentUser);
@@ -283,7 +282,8 @@ export default function ScheduleScreen() {
                     color: color,
                     originalEvent: {
                         ...evt,
-                        ids: mergedIds,
+                        ids: mergedEvtIds,
+                        mergedCalendarIds: mergedCalIds,
                         sourceCalendars: uniqueSourceCalendars,
                         source: { name: sourceName },
                         currentUserRSVP // Store for filtering if needed
@@ -291,8 +291,9 @@ export default function ScheduleScreen() {
                     typeTag: assignedType ? assignedType.title : null,
                     difficulty: difficultyResult, // Use full difficulty object
                     isEnglish: flags?.isEnglish,
-                    movable: flags?.movable,
+                    movable: flags?.movable || isPersonal,
                     isSkippable: flags?.skippable || currentUserRSVP === 'tentative',
+                    isPersonal: isPersonal,
                     needPrep: flags?.needPrep,
                     isRecurrent: !!evt.recurrenceRule, // Non-null means recurring
                     hasRSVPNo: currentUserRSVP === 'declined', // Add flag for easier filtering
@@ -663,9 +664,24 @@ export default function ScheduleScreen() {
 
 
 
+    const enrichedLunchEvents = useMemo(() => {
+        return lunchEvents.map(evt => {
+            // Match icon and other properties from assignments
+            const assignedTypeId = assignments[evt.title];
+            const assignedType = assignedTypeId ? eventTypes.find(t => t.id === assignedTypeId) : null;
+            return {
+                ...evt,
+                icon: assignedType?.icon,
+                isInverted: assignedType?.isInverted,
+                hideBadges: assignedType?.hideBadges,
+                // Ensure difficulty is handled if needed, though usually suggestions have their own logic
+            };
+        });
+    }, [lunchEvents, assignments, eventTypes]);
+
     const allEvents = useMemo(() => {
-        return [...events, ...timeRangeEvents, ...focusRanges, ...freeTimeZones, ...lunchEvents];
-    }, [events, timeRangeEvents, focusRanges, freeTimeZones, lunchEvents]);
+        return [...events, ...timeRangeEvents, ...focusRanges, ...freeTimeZones, ...enrichedLunchEvents];
+    }, [events, timeRangeEvents, focusRanges, freeTimeZones, enrichedLunchEvents]);
 
     const eventCellStyle = useCallback((event: any) => {
         const style: any = {
@@ -698,38 +714,146 @@ export default function ScheduleScreen() {
     }, [workRanges]);
 
     const handleEventDrop = async (event: any, newDate: Date) => {
-        // Only allow dropping reminders for now
-        if (event.typeTag !== 'REMINDER' && !event.originalEvent?.fileUri) {
-            alert('Only reminders can be rescheduled locally.');
+        console.log('[ScheduleScreen] handleEventDrop initiated', { title: event.title, newDate });
+        // Only allow dropping reminders or personal events
+        const isReminder = event.typeTag === 'REMINDER' || !!event.originalEvent?.fileUri;
+        const isPersonalEvent = event.isPersonal && event.originalEvent?.id;
+
+        console.log('[ScheduleScreen] handleEventDrop checks', { isReminder, isPersonalEvent });
+
+        if (!isReminder && !isPersonalEvent) {
+            alert('Only reminders and personal events can be rescheduled.');
             return;
         }
 
-        const originalReminder = event.originalEvent;
-        // const oldTime = originalReminder.reminderTime;
-        const newTimeStr = toLocalISOString(newDate);
+        if (isReminder) {
+            const originalReminder = event.originalEvent;
+            console.log('[ScheduleScreen] handleEventDrop Reminder', { originalReminder });
+            // const oldTime = originalReminder.reminderTime;
+            const newTimeStr = toLocalISOString(newDate);
+
+            // Optimistic Update
+            const updatedReminders = cachedReminders.map((r: any) => {
+                if (r.fileUri === originalReminder.fileUri) {
+                    return { ...r, reminderTime: newTimeStr };
+                }
+                return r;
+            });
+            setCachedReminders(updatedReminders);
 
-        // Optimistic Update
-        const updatedReminders = cachedReminders.map((r: any) => {
-            if (r.fileUri === originalReminder.fileUri) {
-                return { ...r, reminderTime: newTimeStr };
+            // Persist
+            try {
+                await updateReminder(
+                    originalReminder.fileUri,
+                    newTimeStr
+                );
+            } catch (e) {
+                console.error('[ScheduleScreen] Failed to update reminder drop', e);
+                alert('Failed to reschedule reminder.');
+                fetchEvents();
             }
-            return r;
-        });
-        setCachedReminders(updatedReminders);
+        } else {
+            console.log('!!! LOUD !!! [ScheduleScreen] handleEventDrop Step 1: Personal Event Start', { 
+                eventId: event.originalEvent?.id,
+                ids: event.originalEvent?.ids,
+                calendarId: event.originalEvent?.calendarId,
+                isRecurrent: event.isRecurrent 
+            });
+            try {
+                // Handle personal event reschedule
+                console.log('!!! LOUD !!! [ScheduleScreen] handleEventDrop Step 2: Calculating Duration', { start: event.start, end: event.end });
+                const duration = dayjs(event.end).diff(dayjs(event.start), 'millisecond');
+                console.log('!!! LOUD !!! [ScheduleScreen] handleEventDrop Step 3: Duration', duration);
+                
+                const newStart = newDate;
+                const newEnd = new Date(newStart.getTime() + duration);
+                console.log('!!! LOUD !!! [ScheduleScreen] handleEventDrop Step 4: New Dates', { newStart, newEnd });
+
+                // Optimistic Update in events list
+                console.log('!!! LOUD !!! [ScheduleScreen] handleEventDrop Step 5: setEvents');
+                setEvents(prev => prev.map(e => {
+                    const match = e.originalEvent?.id === event.originalEvent?.id && 
+                                 (!e.start || new Date(e.start).getTime() === new Date(event.start).getTime());
+                    if (match) {
+                        return { ...e, start: newStart, end: newEnd };
+                    }
+                    return e;
+                }));
 
-        // Persist
-        try {
-            await updateReminder(
-                originalReminder.fileUri,
-                newTimeStr
-            );
-        } catch (e) {
-            console.error('[ScheduleScreen] Failed to update reminder drop', e);
-            alert('Failed to reschedule reminder.');
-            // Revert (fetchEvents will likely handle this on mount/focus, but manual revert is better)
-            // For now relying on store state which might be stale if we don't revert explicitly.
-            // But we didn't save old cachedReminders locally in this scop.
-            // Use setCachedReminders((prev) => ...) pattern if needed.
+                const rawIds = event.originalEvent?.ids || [event.originalEvent?.id];
+                // Filter out any IDs that are clearly just the calendar ID if we have other choices
+                const ids = rawIds.filter((id: any) => id && (rawIds.length === 1 || String(id) !== String(event.originalEvent?.calendarId)));
+                
+                const executeUpdate = async (options: any = {}) => {
+                    console.log('!!! LOUD !!! [ScheduleScreen] executeUpdate calling', { ids, options });
+                    const isAndroid = Platform.OS === 'android';
+                    
+                    for (const id of ids) {
+                        try {
+                            let targetId = id;
+                            let finalOptions = { ...options };
+
+                            if (isAndroid && options.futureEvents) {
+                                // Android doesn't support futureEvents; update master event instead
+                                // Master ID is usually the first part of instance ID
+                                targetId = String(id).split(':')[0];
+                                delete finalOptions.futureEvents;
+                                console.log(`!!! LOUD !!! [ScheduleScreen] Android Series Update: targeting master ID ${targetId}`);
+                            }
+
+                            console.log(`!!! LOUD !!! [ScheduleScreen] Updating ID: ${targetId}`, { finalOptions });
+                            await updateCalendarEvent(targetId, {
+                                startDate: newStart,
+                                endDate: newEnd,
+                                title: event.title || event.originalEvent?.title || 'Event',
+                                calendarId: event.originalEvent?.calendarId
+                            }, finalOptions);
+                            
+                            console.log(`!!! LOUD !!! [ScheduleScreen] Successfully updated ID: ${targetId}`);
+                        } catch (err) {
+                            console.warn(`!!! LOUD !!! [ScheduleScreen] Failed to update event ID ${id}:`, err);
+                        }
+                    }
+                    console.log('!!! LOUD !!! [ScheduleScreen] handleEventDrop Step 7: Completed updates');
+                    setTimeout(() => {
+                        console.log('!!! LOUD !!! [ScheduleScreen] handleEventDrop Step 8: fetching fresh events');
+                        fetchEvents();
+                    }, 500);
+                };
+
+                if (event.isRecurrent) {
+                    Alert.alert(
+                        "Recurring Event",
+                        "Do you want to update only this instance or the whole series?",
+                        [
+                            { 
+                                text: "Cancel", 
+                                onPress: () => {
+                                    console.log('!!! LOUD !!! [ScheduleScreen] User cancelled recurring update');
+                                    fetchEvents();
+                                }, 
+                                style: "cancel" 
+                            },
+                            { 
+                                text: "This Instance", 
+                                // Add slight delay to ensure Alert is dismissed
+                                onPress: () => setTimeout(() => executeUpdate({ instanceStartDate: new Date(event.start) }), 50)
+                            },
+                            { 
+                                text: "Whole Series", 
+                                // Add slight delay to ensure Alert is dismissed
+                                onPress: () => setTimeout(() => executeUpdate({ futureEvents: true }), 50)
+                            }
+                        ]
+                    );
+                } else {
+                    executeUpdate();
+                }
+            } catch (e) {
+                console.error('!!! LOUD !!! [ScheduleScreen] Error in handleEventDrop Personal Path', e);
+                alert('Failed to reschedule event.');
+                fetchEvents(); // Revert
+            }
         }
     };
 
diff --git a/components/ui/calendar/components/CalendarBody.tsx b/components/ui/calendar/components/CalendarBody.tsx
index 733ac16..56aeaca 100644
--- a/components/ui/calendar/components/CalendarBody.tsx
+++ b/components/ui/calendar/components/CalendarBody.tsx
@@ -455,6 +455,8 @@ function _CalendarBody<T extends ICalendarEventBase>({
           maxHour={maxHour}
           minHour={minHour}
           hours={hours.length}
+          cellHeight={cellHeight}
+          onEventDrop={onEventDrop}
         />
       )
     },
diff --git a/components/ui/calendar/components/CalendarEvent.tsx b/components/ui/calendar/components/CalendarEvent.tsx
index c5f5a01..98e811d 100644
--- a/components/ui/calendar/components/CalendarEvent.tsx
+++ b/components/ui/calendar/components/CalendarEvent.tsx
@@ -1,6 +1,7 @@
 import dayjs from 'dayjs'
 import * as React from 'react'
 import type { AccessibilityProps } from 'react-native'
+import { StyleSheet } from 'react-native'
 import { OVERLAP_OFFSET, u } from '../commonStyles'
 import { useCalendarTouchableOpacityProps } from '../hooks/useCalendarTouchableOpacityProps'
 import type { EventCellStyle, EventRenderer, ICalendarEventBase, Mode } from '../interfaces'
@@ -9,6 +10,8 @@ import { DAY_MINUTES, getRelativeTopInDay, getStyleForOverlappingEvent } from '.
 import { typedMemo } from '../utils/react'
 import { DefaultCalendarEventRenderer } from './DefaultCalendarEventRenderer'
 
+import { DraggableEventWrapper } from './DraggableEventWrapper'
+
 const getEventCellPositionStyle = (start: Date, end: Date, minHour: number, hours: number) => {
   const totalMinutesInRange = (DAY_MINUTES / 24) * hours
   const durationInMinutes = dayjs(end).diff(start, 'minute')
@@ -37,6 +40,8 @@ interface CalendarEventProps<T extends ICalendarEventBase> {
   maxHour?: number
   minHour?: number
   hours?: number
+  cellHeight?: number
+  onEventDrop?: (event: T, newDate: Date) => void
 }
 
 function _CalendarEvent<T extends ICalendarEventBase>({
@@ -54,6 +59,8 @@ function _CalendarEvent<T extends ICalendarEventBase>({
   mode,
   minHour = 0,
   hours = 24,
+  cellHeight = 50,
+  onEventDrop,
 }: CalendarEventProps<T>) {
   const theme = useTheme()
 
@@ -62,38 +69,71 @@ function _CalendarEvent<T extends ICalendarEventBase>({
     [theme],
   )
 
+  // Move position styles calculation out to use it for wrapper if needed
+  const overlapStyles = React.useMemo(() => {
+    return getStyleForOverlappingEvent(eventOrder, overlapOffset, palettes, eventCount)
+  }, [eventOrder, overlapOffset, palettes, eventCount])
+
+  // Split layout and background to avoid "strange background" on wrapper
+  const { backgroundColor: overlapBackgroundColor, ...layoutOnlyOverlapStyles } = (overlapStyles as any)
+
+  const layoutStyles = React.useMemo(() => {
+    return mode === 'schedule'
+      ? [layoutOnlyOverlapStyles]
+      : [
+        getEventCellPositionStyle(event.start, event.end, minHour, hours),
+        layoutOnlyOverlapStyles,
+        u.absolute,
+        u['mt-2'],
+      ]
+  }, [mode, layoutOnlyOverlapStyles, event.start, event.end, minHour, hours])
+
+  // Add movable check
+  const isMovable = (event as any).movable
+  const canDrag = isMovable && !!onEventDrop && mode !== 'schedule'
+
   const touchableOpacityProps = useCalendarTouchableOpacityProps({
     event,
     eventCellStyle,
     eventCellAccessibilityProps,
     onPressEvent,
-    injectedStyles:
-      mode === 'schedule'
-        ? [getStyleForOverlappingEvent(eventOrder, overlapOffset, palettes, eventCount)]
-        : [
-          getEventCellPositionStyle(event.start, event.end, minHour, hours),
-          getStyleForOverlappingEvent(eventOrder, overlapOffset, palettes, eventCount),
-          u.absolute,
-          u['mt-2'],
-        ],
+    injectedStyles: canDrag 
+      ? [u.absolute, { width: '100%', height: '100%' }] 
+      : [{ backgroundColor: overlapBackgroundColor }, ...layoutStyles],
   })
 
   const textColor = React.useMemo(() => {
     const fgColors = palettes.map((p) => p.contrastText)
     return fgColors[eventCount % fgColors.length] || fgColors[0]
   }, [eventCount, palettes])
-  if (renderEvent) {
-    return renderEvent(event, touchableOpacityProps)
+
+  const content = renderEvent
+    ? renderEvent(event, touchableOpacityProps)
+    : (
+      <DefaultCalendarEventRenderer
+        event={event}
+        showTime={showTime}
+        ampm={ampm}
+        touchableOpacityProps={touchableOpacityProps}
+        textColor={eventCellTextColor || textColor}
+      />
+    )
+
+  if (!canDrag) {
+    return content
   }
 
   return (
-    <DefaultCalendarEventRenderer
-      event={event}
-      showTime={showTime}
-      ampm={ampm}
-      touchableOpacityProps={touchableOpacityProps}
-      textColor={eventCellTextColor || textColor}
-    />
+    <DraggableEventWrapper
+      eventStart={dayjs(event.start).toDate()}
+      minHour={minHour}
+      cellHeight={cellHeight}
+      onDrop={(newDate) => onEventDrop?.(event, newDate)}
+      enabled={true} // Already checked by canDrag
+      style={layoutStyles}
+    >
+      {content}
+    </DraggableEventWrapper>
   )
 }
 
diff --git a/components/ui/calendar/hooks/useLunchSuggestion.ts b/components/ui/calendar/hooks/useLunchSuggestion.ts
index 6e0673a..ccdde8c 100644
--- a/components/ui/calendar/hooks/useLunchSuggestion.ts
+++ b/components/ui/calendar/hooks/useLunchSuggestion.ts
@@ -146,7 +146,7 @@ export function useLunchSuggestion(
                 }
 
                 lunchEvents.push({
-                    title: 'Lunch (Suggested)',
+                    title: lunchRangeDef.title,
                     start: bestSlot.start.toDate(),
                     end: bestSlot.start.add(60, 'minute').toDate(),
                     color: lunchRangeDef.color,
diff --git a/components/ui/calendar/interfaces.ts b/components/ui/calendar/interfaces.ts
index 3f1bed8..daba4fa 100644
--- a/components/ui/calendar/interfaces.ts
+++ b/components/ui/calendar/interfaces.ts
@@ -27,6 +27,10 @@ export interface ICalendarEventBase {
    * Type of the event for advanced visualization
    */
   type?: 'marker' | 'zone' | 'range' | 'event'
+  /**
+   * Whether the event can be moved/rescheduled via drag and drop
+   */
+  movable?: boolean
 }
 
 export interface TimeRangeDefinition {
diff --git a/services/calendarService.ts b/services/calendarService.ts
index bb5ff82..d5c11a4 100644
--- a/services/calendarService.ts
+++ b/services/calendarService.ts
@@ -98,6 +98,51 @@ export const getAttendeesForEvent = async (eventId: string): Promise<Calendar.At
     }
 };
 
+export const updateCalendarEvent = async (
+    eventId: string,
+    eventData: Partial<Calendar.Event>,
+    options: Calendar.RecurringEventOptions = {}
+) => {
+    console.log('[CalendarService] updateCalendarEvent called', { eventId, eventData, options });
+    const hasPermission = await ensureCalendarPermissions();
+    if (!hasPermission) {
+        console.error('[CalendarService] updateCalendarEvent: Missing permissions');
+        throw new Error("Missing calendar permissions");
+    }
+
+    try {
+        const isAndroid = Platform.OS === 'android';
+        const formattedData: any = { ...eventData };
+
+        // Android native bridge is extremely sensitive to date types.
+        // Timestamps (milliseconds) are the most robust "primitive" format.
+        if (formattedData.startDate instanceof Date) {
+            formattedData.startDate = isAndroid ? formattedData.startDate.getTime() : formattedData.startDate.toISOString();
+        }
+        if (formattedData.endDate instanceof Date) {
+            formattedData.endDate = isAndroid ? formattedData.endDate.getTime() : formattedData.endDate.toISOString();
+        }
+
+        const formattedOptions: any = { ...options };
+        if (formattedOptions.instanceStartDate instanceof Date) {
+            formattedOptions.instanceStartDate = isAndroid ? formattedOptions.instanceStartDate.getTime() : formattedOptions.instanceStartDate.toISOString();
+        }
+
+        console.log(`[CalendarService] updateCalendarEvent: calling expo-calendar updateEventAsync (${Platform.OS})`, {
+            eventId,
+            formattedData,
+            formattedOptions
+        });
+
+        const result = await Calendar.updateEventAsync(eventId, formattedData, formattedOptions);
+        console.log('[CalendarService] updateCalendarEvent: expo-calendar success', result);
+        return result;
+    } catch (e) {
+        console.error('[CalendarService] updateCalendarEvent: expo-calendar FAILED', e);
+        throw e;
+    }
+};
+
 export const createCalendarEvent = async (calendarId: string, eventData: Partial<Calendar.Event>) => {
     const hasPermission = await ensureCalendarPermissions();
     if (!hasPermission) throw new Error("Missing calendar permissions");
diff --git a/services/calendarUtils.ts b/services/calendarUtils.ts
index fc8aefe..6d77e0a 100644
--- a/services/calendarUtils.ts
+++ b/services/calendarUtils.ts
@@ -15,16 +15,19 @@ export const mergeDuplicateEvents = (events: Event[], priorityCalendarId?: strin
 
         const existing = uniqueEventsMap.get(key);
         if (!existing) {
-            // Initialize mergedCalendarIds with the current event's calendarId
+            // Initialize merged IDs
             (event as any).mergedCalendarIds = [event.calendarId];
+            (event as any).mergedEventIds = [event.id];
             uniqueEventsMap.set(key, event);
         } else {
             // Duplicate found
             const existingCalId = existing.calendarId;
             const newCalId = event.calendarId;
+            const newEvtId = event.id;
 
             // Get existing merged IDs or initialize if missing (sanity check)
-            const existingMergedIds = (existing as any).mergedCalendarIds || [existingCalId];
+            const existingMergedCalIds = (existing as any).mergedCalendarIds || [existingCalId];
+            const existingMergedEvtIds = (existing as any).mergedEventIds || [existing.id];
 
             // Deduplicate attendees
             const mergeAttendees = (a: any[] = [], b: any[] = []) => {
@@ -43,15 +46,15 @@ export const mergeDuplicateEvents = (events: Event[], priorityCalendarId?: strin
             if (priorityCalendarId && String(event.calendarId) === String(priorityCalendarId)) {
                 // Overwrite existing if current event is from the priority calendar
                 // Transfer accumulated IDs to the new event
-                (event as any).mergedCalendarIds = [...existingMergedIds, newCalId];
+                (event as any).mergedCalendarIds = [...existingMergedCalIds, newCalId];
+                (event as any).mergedEventIds = [...existingMergedEvtIds, newEvtId];
                 (event as any).attendees = mergedAttendees;
-                // console.log(`[EventMerge] -> SWAPPING for priority calendar: ${event.title}`);
                 uniqueEventsMap.set(key, event);
             } else {
-                // Keep existing, but add the new calendar ID to it
-                (existing as any).mergedCalendarIds = [...existingMergedIds, newCalId];
+                // Keep existing, but add the new IDs to it
+                (existing as any).mergedCalendarIds = [...existingMergedCalIds, newCalId];
+                (existing as any).mergedEventIds = [...existingMergedEvtIds, newEvtId];
                 (existing as any).attendees = mergedAttendees;
-                // console.log(`[EventMerge] -> Keeping existing (New is not priority): ${event.title} (Existing: ${existingCalId})`);
             }
         }
     }
